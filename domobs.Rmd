---
title: "Dominance Scoring 2024"
subtitle: "draft" 
author:     | 
    | Quinlan Mann
    | 400420834
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  pdf_document:
    toc: no
  word_document:
    toc: no
  html_document:
    toc: no
    keep_md: yes
md_document:
    variant: markdown_github
header-includes:
  - \usepackage{lineno}
  - \linenumbers
  - \usepackage{setspace}
  - \AtBeginEnvironment{tabular}{\singlespacing}
  - \AtBeginEnvironment{lltable}{\singlespacing}
  - \AtBeginEnvironment{tablenotes}{\doublespacing}
linestretch: 2
always_allow_html: true
---

```{r, setup, include=F}
knitr::opts_chunk$set(echo = FALSE, fig.width=6, fig.height=4, warning = F, message = F)
options(digits = 3)
```

## R Markdown

```{r libraries, include=F}
library(tidyverse)
library(reshape2)
library(EloRating)
library(RCurl)
library(kableExtra)
library(knitr)
```

## Creating Dataframes for each territory sampeled in 2011-12

```{r Datafrmes,include=F, echo=FALSE}
#pulling the data from Github
Doms<-getURL("https://raw.githubusercontent.com/QuinlanMann/Pukeko_Dom_Observations/main/Dom_Obs_Master.csv")
Doms<-read.csv(text=Doms)

#summarizing counts of interactions between individual birds within groups
Doms<-Doms%>%
  group_by(Group, Dominant, Subordinate)%>%
  summarize(count=length(Interaction))

#Reassigning each group into unique dataframes
for(i in as.list(unique(Doms$Group))) 
  {assign(paste("DS_",i, sep=""), filter(Doms, Group == i))}

#making a list of dataframes created in the previous step
list_of_objects <- mget(ls(.GlobalEnv, pattern = "DS_*"), envir = .GlobalEnv)

#removing the group identifier column from the list of dfs
list_of_objects <- lapply(list_of_objects, 
                  function(x) x[,-c(1)])

#taking the modified dataframes and writing them to the Global environment
list2env(list_of_objects, .GlobalEnv)
```

```{r Matrix Creation, include=F}
# Function for creating a  matrix to calculate David's Scores
matrix_maker<-function(x){
  # construct 0 matrix of correct dimensions with row and column names
  myMat <- matrix(0, #filled with zeros
                  length(sort(unique(unlist(x[1:2])))), #length of all unique bird name values in rows and columns
                  length(sort(unique(unlist(x[1:2])))), #length of all unique bird name values in rows and columns
                  dimnames = list(sort(unique(unlist(x[1:2]))), #naming rows and columns after all unique bird name values in dataframe
                                  sort(unique(unlist(x[1:2])))))
  # fill in the matrix with matrix indexing on row and column names
  myMat[as.matrix(x[c("Dominant", "Subordinate")])] <- x[["count"]]
  return(myMat)
}

#applying function to the list of objects to create square matrices
list_of_objects<-lapply(list_of_objects, matrix_maker)
list_of_objects2<-list_of_objects

#taking the modified dataframes and writing them to the Global environment
list2env(list_of_objects, .GlobalEnv)
```

```{r David Score Calculations, include=F}
#applying ELoRating::DS function to the  
list_of_objects<-lapply(list_of_objects, DS)
#binding all David's Scores into one Dataframe
David_Score<-bind_rows(list_of_objects, .id = "Group")

#viewing all David's scores as a table
kable(David_Score, "latex", booktabs = TRUE, longtable = TRUE, caption = "Test") %>%
  kable_styling(latex_options = c("hold_position", "repeat_header"))
```

```{r David Score ranks within groups and plotting to get steepness 1}
David_Score<-David_Score %>%
  group_by(Group) %>%
  mutate(good_ranks = order(order(normDS, decreasing=TRUE)))

library(ggpmisc)

ggplot(David_Score, aes(x=good_ranks, y=normDS))+
  stat_poly_line() +
  stat_poly_eq(use_label(c("eq", "R2"))) +
  geom_point()+
  facet_wrap(~Group)+
  ggthemes::theme_few()
```


```{r David Score ranks within groups and plotting to get steepness 2}
ggplot(David_Score, aes(y=normDS, good_ranks, color=Group))+
  geom_point(show.legend = FALSE, aes(shape=Group))+
  geom_smooth(method="lm", show.legend = FALSE)+
  ggthemes::theme_few()

list_of_Scores = split(David_Score, David_Score$Group)

regression_maker = function(data, var1, var2) {
  fit = lm(normDS ~ good_ranks, data = data)
  coef(fit)[2]
  }

regression_maker(David_Score)

slopes<-map_dfr(list_of_Scores, regression_maker, .id = "id")
slopes<-rename(slopes, Slopes="good_ranks")
```


```{r, funciton to randomize matrices and gernate a regression, include=F}
reg_randomizer<-function(x){
  #quick check to see if the matrix is square
  x<-as.matrix(x)
  if(length(rownames(x))!=length(colnames(x)))
    return("the matrix is not square")
  #adds the values of the matrix, and transposed matrix together to get
  #the sum of interactions
  x<-x+t(x)
  #removes the lower half so I am not adding the sum twice
  x[lower.tri(x)] <- 0  
  x<-as.data.frame(x)
  #creates the winner ID column so I can make the dataframe long
  x<-tibble::rownames_to_column(x, "BIRD1")
  #unique total value of columns per matrix
  N<-length(colnames(x))
  #creates a unique dataframe that has a list of all interaction pairs (totals)
  x<-pivot_longer(as.data.frame(x), 
                  cols = c(2:N), 
                  names_to = "BIRD2", 
                  values_to = "INT")
  x<-filter(x, INT > 0)
  #creating a random number of wins/losses conditional on how many interactions
  x$WIN<-sapply(x$INT, function(y) sample(0:y, 1))
  x$LOSS<-x$INT-x$WIN
  #creating two dataframes of wins and losses
  wins<-x[,c(1,2,4)]
  wins<-wins%>%
    rename(Dominant=BIRD1, 
           Subordinate=BIRD2, 
           count=WIN)
  loss<-x[,c(2,1,5)]
  loss<-loss%>%
    rename(Dominant=BIRD2, 
           Subordinate=BIRD1, 
           count=LOSS)
  #binding the new dataframes
  x<-rbind(wins,loss)
  #making them back to a matrix
  myMat <- matrix(0, #filled with zeros
                  length(sort(unique(unlist(x[1:2])))), #length of all unique bird name values in rows and columns
                  length(sort(unique(unlist(x[1:2])))), #length of all unique bird name values in rows and columns
                  dimnames = list(sort(unique(unlist(x[1:2]))), #naming rows and columns after all unique bird name values in dataframe
                                  sort(unique(unlist(x[1:2])))))
  # fill in the matrix with matrix indexing on row and column names
  myMat[as.matrix(x[c("Dominant", "Subordinate")])] <- x[["count"]]
  #DS calculation from EloRating Package
  rn <- rownames(myMat)
  cn <- colnames(myMat)
  tmat <- t(myMat)
  summatrix <- myMat + tmat
  diag(summatrix) <- 0
  summatrix <- replace(summatrix, summatrix == 0, NA)
  l1 <- which(is.na(summatrix), arr.ind = TRUE)
  #this is using the Dij calculation change if you decide to use the Pij calculation
  propmatrix <- (myMat + 0.5)/(tmat + myMat + 1)
  propmatrix <- replace(propmatrix, l1, 0)
  w <- rowSums(propmatrix)
  w2 <- propmatrix %*% w
  l <- rowSums(t(propmatrix))
  l2 <- t(propmatrix) %*% l
  DS <- w + w2 - l - l2
  normDS <- ((DS + ((length(DS)) * (length(DS) - 1))/2))/length(DS)
  good_ranks <- order(order(normDS, decreasing=TRUE))
  res <- data.frame(ID = rn, DS = DS, normDS = normDS, good_ranks = good_ranks)
  res <- res[order(res$DS, decreasing = TRUE), ]
  rownames(res) <- NULL
  #return(res)
  r2<-summary(lm(normDS ~ good_ranks, data = res))[["coefficients"]][2]
  return(r2)
}
```


```{r, Randomization and creation of dataset, include=F}
B=1000

results <- data.frame(matrix(ncol = length(list_of_objects2), nrow = B))
x <- unique(ls(list_of_objects2))
colnames(results) <- x

for(i in 1:length(list_of_objects2))
{
  values <- list_of_objects2[[i]]
  results[, i] <- as.numeric(replicate(B, 
                                  reg_randomizer(values), 
                                  simplify = FALSE))
  
}

results<-tibble::rownames_to_column(results, "iteration")
results<-pivot_longer(results, col=c(2:16))
results<-rename(results, id=name)
```


```{r, Code to determine the significance}
#creating confidence intervals and determining "significance"
slopes2<-results %>%
  group_by(id) %>%
  summarise(lCI=quantile(value, 0.025), 
            uCI=quantile(value, 0.975))
slopes2<-merge(slopes, slopes2, by="id")
slopes2$sig<-if_else(slopes2$Slopes>slopes2$lCI & slopes2$Slopes<slopes2$uCI, 
                     "p>0.05", "p<0.05")
```


```{r, Visualization}
ggplot(results)+
  geom_density(aes(value), color="darkblue", fill="lightblue")+
  facet_wrap(~ id)+
  geom_vline(data = slopes2,
             mapping = aes(xintercept = Slopes), 
             linetype = 'dashed', 
             color="red")+
  ggthemes::theme_few()+
  theme(legend.position = "none",  # Hide the legend as it's redundant with facets
        strip.text = element_text(size = 12, face = "bold")) +  # Bold the facet labels
  geom_text(data = slopes2, aes(y = 20, x = -.90, label = sig), position = position_nudge(0.2), size = 4)
```
